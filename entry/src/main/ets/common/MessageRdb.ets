import { common } from '@kit.AbilityKit';
import { relationalStore, ValuesBucket } from '@kit.ArkData';
import { SessionModel } from '../model/MessageModel';

/**
 * æ¶ˆæ¯å®ä½“ (å¯¹åº” RDB å­˜å‚¨ç»“æ„)
 */
export interface MessageEntity {
  id?: number;         // è‡ªå¢ä¸»é”®
  sessionId: string;   // å…³è”ä¼šè¯ID
  msgId: string;       // æ¶ˆæ¯UUID
  senderId: number;    // å‘é€è€…ID
  role: number;        // å‘é€è€…è§’è‰² (0:æˆ‘, 1:å¯¹æ–¹) - ç”¨äºUIåˆ¤æ–­å·¦å³
  content: string;     // å†…å®¹
  type: number;        // æ¶ˆæ¯ç±»å‹
  createTime: number;  // æ—¶é—´æˆ³
  orderId?: number;    // å…³è”è®¢å•ID (å¯é€‰)
}

/**
 * ğŸ“¨ æ¶ˆæ¯ä¸­å¿ƒæ•°æ®åº“å·¥å…·ç±» (RDB)
 * ç®¡ç†ä¼šè¯åˆ—è¡¨ (tb_session) å’Œ æ¶ˆæ¯æ˜ç»† (tb_message)
 */
export class MessageRdb {
  private static readonly DB_NAME = 'SkyDelivery_Merchant_Msg.db'; 
  private static readonly TABLE_SESSION = 'tb_session';
  private static readonly TABLE_MESSAGE = 'tb_message';
  private static rdbStore: relationalStore.RdbStore | null = null;
  
  // å»ºè¡¨è¯­å¥ - ä¼šè¯è¡¨
  private static readonly SQL_CREATE_SESSION = `
    CREATE TABLE IF NOT EXISTS tb_session (
      session_id TEXT PRIMARY KEY,
      title TEXT,
      avatar TEXT,
      last_msg TEXT,
      last_time INTEGER,
      unread_count INTEGER
    )
  `;
  
  // å»ºè¡¨è¯­å¥ - æ¶ˆæ¯è¡¨
  private static readonly SQL_CREATE_MESSAGE = `
    CREATE TABLE IF NOT EXISTS tb_message (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id TEXT NOT NULL,
      msg_id TEXT,
      sender_id INTEGER,
      role INTEGER,
      content TEXT,
      type INTEGER,
      create_time INTEGER,
      order_id INTEGER
    )
  `;

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  static async init(context: common.UIAbilityContext) {
    if (MessageRdb.rdbStore) {
      return;
    }

    const config: relationalStore.StoreConfig = {
      name: MessageRdb.DB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1
    };

    try {
      MessageRdb.rdbStore = await relationalStore.getRdbStore(context, config);

      // åˆ›å»ºè¡¨ (å¦‚æœä¸å­˜åœ¨)
      await MessageRdb.rdbStore.executeSql(MessageRdb.SQL_CREATE_SESSION);
      await MessageRdb.rdbStore.executeSql(MessageRdb.SQL_CREATE_MESSAGE);

      console.info('å–µï¼å•†å®¶ç«¯æ¶ˆæ¯æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ ğŸ“¨');
    } catch (err) {
      console.error('æ¶ˆæ¯æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥', err);
    }
  }

  // ==================== ä¼šè¯ç®¡ç† ====================

  /**
   * ä¿å­˜æˆ–æ›´æ–°ä¼šè¯
   */
  static async saveSession(session: SessionModel): Promise<boolean> {
    if (!MessageRdb.rdbStore) {
      return false;
    }

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.equalTo('session_id', session.sessionId);
    const resultSet = await MessageRdb.rdbStore.query(predicates);

    const values: ValuesBucket = {
      'session_id': session.sessionId,
      'title': session.title,
      'avatar': typeof session.avatar === 'string' ? session.avatar : '',
      'last_msg': session.lastMsg,
      'last_time': session.lastTime
    };

    try {
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        const currentUnread = resultSet.getLong(resultSet.getColumnIndex('unread_count'));
        let newUnread = 0;
        if (session.unreadCount === 0) {
          newUnread = 0;
        } else {
          newUnread = currentUnread + session.unreadCount;
        }
        values['unread_count'] = newUnread;
        await MessageRdb.rdbStore.update(values, predicates);
      } else {
        values['unread_count'] = session.unreadCount;
        await MessageRdb.rdbStore.insert(MessageRdb.TABLE_SESSION, values);
      }
      return true;
    } catch (e) {
      console.error('ä¿å­˜ä¼šè¯å¤±è´¥', e);
      return false;
    } finally {
      resultSet.close();
    }
  }

  /**
   * æ¸…ç©ºæŒ‡å®šä¼šè¯çš„æœªè¯»æ•°
   */
  static async clearUnread(sessionId: string): Promise<boolean> {
    if (!MessageRdb.rdbStore) return false;
    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.equalTo('session_id', sessionId);
    const values: ValuesBucket = {
      'unread_count': 0
    };
    try {
      await MessageRdb.rdbStore.update(values, predicates);
      return true;
    } catch (e) {
      return false;
    }
  }

  static async getSessionList(): Promise<SessionModel[]> {
    if (!MessageRdb.rdbStore) {
      return [];
    }

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.orderByDesc('last_time');

    const resultSet = await MessageRdb.rdbStore.query(predicates);
    const list: SessionModel[] = [];

    while (resultSet.goToNextRow()) {
      const avatarStr = resultSet.getString(resultSet.getColumnIndex('avatar'));
      list.push(new SessionModel(
        resultSet.getString(resultSet.getColumnIndex('session_id')),
        resultSet.getString(resultSet.getColumnIndex('title')),
        avatarStr,
        resultSet.getString(resultSet.getColumnIndex('last_msg')),
        resultSet.getLong(resultSet.getColumnIndex('last_time')),
        resultSet.getLong(resultSet.getColumnIndex('unread_count'))
      ));
    }
    resultSet.close();
    return list;
  }
  
  static async deleteSession(sessionId: string): Promise<boolean> {
    if (!MessageRdb.rdbStore) return false;
    try {
      const sessPred = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
      sessPred.equalTo('session_id', sessionId);
      await MessageRdb.rdbStore.delete(sessPred);

      const msgPred = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
      msgPred.equalTo('session_id', sessionId);
      await MessageRdb.rdbStore.delete(msgPred);
      return true;
    } catch (e) {
      return false;
    }
  }

  // ==================== æ¶ˆæ¯ç®¡ç† ====================

  static async saveMessage(msg: MessageEntity): Promise<boolean> {
    if (!MessageRdb.rdbStore) return false;
    const values: ValuesBucket = {
      'session_id': msg.sessionId,
      'msg_id': msg.msgId,
      'sender_id': msg.senderId,
      'role': msg.role,
      'content': msg.content,
      'type': msg.type,
      'create_time': msg.createTime,
      'order_id': msg.orderId || null
    };
    try {
      await MessageRdb.rdbStore.insert(MessageRdb.TABLE_MESSAGE, values);
      return true;
    } catch (e) {
      console.error('ä¿å­˜æ¶ˆæ¯å¤±è´¥', e);
      return false;
    }
  }

  /**
   * è·å–æŒ‡å®šä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯æ˜ç»†
   */
  static async getMessages(sessionId: string): Promise<MessageEntity[]> {
    if (!MessageRdb.rdbStore) return [];

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
    predicates.equalTo('session_id', sessionId);
    predicates.orderByAsc('create_time'); // æŒ‰æ—¶é—´é¡ºåºæ’åˆ—å–µ

    const resultSet = await MessageRdb.rdbStore.query(predicates);
    const list: MessageEntity[] = [];

    while (resultSet.goToNextRow()) {
      list.push({
        id: resultSet.getLong(resultSet.getColumnIndex('id')),
        sessionId: resultSet.getString(resultSet.getColumnIndex('session_id')),
        msgId: resultSet.getString(resultSet.getColumnIndex('msg_id')),
        senderId: resultSet.getLong(resultSet.getColumnIndex('sender_id')),
        role: resultSet.getLong(resultSet.getColumnIndex('role')),
        content: resultSet.getString(resultSet.getColumnIndex('content')),
        type: resultSet.getLong(resultSet.getColumnIndex('type')),
        createTime: resultSet.getLong(resultSet.getColumnIndex('create_time')),
        orderId: resultSet.getLong(resultSet.getColumnIndex('order_id'))
      });
    }
    resultSet.close();
    return list;
  }
}