/**
 * HttpUtil,å°è£…RCPå·¥å…·ç±»
 */

import { rcp } from '@kit.RemoteCommunicationKit';
import { Result } from '../model/ResultModel';
import { promptAction } from '@kit.ArkUI';

// TODO: å¦‚æœçœŸæœºè°ƒè¯•ï¼Œè¯·ä¿®æ”¹ä¸ºç”µè„‘çš„å±€åŸŸç½‘IP
const BASE_URL = 'http://192.168.0.210:8080/admin/app/'; 
const TIMEOUT = 10000;

/**
 * æ‹¦æˆªå™¨ï¼Œè´Ÿè´£ç»™è¯·æ±‚å¤´åŠ ä¸Š token
 */
class TokenInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    const token = AppStorage.get<string>('token');
    
    // ğŸ¾ è°ƒè¯•æ—¥å¿—ï¼šæ£€æŸ¥æ‹¦æˆªå™¨æ˜¯å¦æ‹¿åˆ°äº† Token
    if (token) {
      console.info('å–µï¼[TokenInterceptor] å‘ç° Tokenï¼Œå‡†å¤‡æ³¨å…¥ Header');
      if (!context.request.headers) {
        context.request.headers = {};
      }
      // å¼ºåˆ¶è½¬å‹ä»¥ç¡®ä¿èƒ½è®¾ç½®å±æ€§
      (context.request.headers as Record<string, string | string[]> )['token'] = token;
    } else {
      console.warn('å–µï¼[TokenInterceptor] æœªå‘ç° Tokenï¼Œæœ¬æ¬¡è¯·æ±‚å¯èƒ½æŠ¥é”™ 401');
    }
    
    return next.handle(context);
  }
}

class LogInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    console.info(`å–µï¼[Request] URL: ${context.request.url.href}`);
    const response = await next.handle(context);
    console.info(`å–µï¼[Response] Code: ${response.statusCode} URL: ${context.request.url.href}`);
    return response;
  }
}

/**
 * å…¨å±€Httpå·¥å…·
 */
export class HttpUtil {
  private static session: rcp.Session | null = null;
  private static uiContext: UIContext | null = null;

  static setContext(context: UIContext) {
    HttpUtil.uiContext = context;
  }

  private static init() {
    if (HttpUtil.session === null) {
      HttpUtil.session = rcp.createSession({
        baseAddress: BASE_URL,
        headers: {
          'Content-Type': 'application/json'
        },
        interceptors: [new TokenInterceptor(), new LogInterceptor()],
        requestConfiguration: {
          transfer: {
            timeout: {
              connectMs: TIMEOUT,
              transferMs: TIMEOUT
            }
          }
        }
      });
    }
  }

  static async post<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();
    if (url.startsWith('/')) {
      url = url.substring(1);
    }
    try {
      const resp = await HttpUtil.session!.post(url, data);
      return HttpUtil.handleResponse<T>(resp);
    } catch (err) {
      return HttpUtil.handleError(err);
    }
  }

  static async get<T>(url: string): Promise<T> {
    HttpUtil.init();
    if (url.startsWith('/')) {
      url = url.substring(1);
    }
    try {
      const resp = await HttpUtil.session!.get(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch (err) {
      return HttpUtil.handleError(err);
    }
  }

  static async put<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();
    if (url.startsWith('/')) {
      url = url.substring(1);
    }
    try {
      const resp = await HttpUtil.session!.put(url, data);
      return HttpUtil.handleResponse<T>(resp);
    } catch (err) {
      return HttpUtil.handleError(err);
    }
  }

  static async delete<T>(url: string): Promise<T> {
    HttpUtil.init();
    if (url.startsWith('/')) {
      url = url.substring(1);
    }
    try {
      const resp = await HttpUtil.session!.delete(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch (err) {
      return HttpUtil.handleError(err);
    }
  }

  /**
   * ğŸ“¤ ä¸Šä¼ æ–‡ä»¶ (å·²ç»è¡¥å›æ¥å•¦å–µï¼)
   * @param url ç›¸å¯¹è·¯å¾„ï¼Œä¾‹å¦‚ '/common/upload'
   * @param fileUri æ–‡ä»¶æœ¬åœ°è·¯å¾„
   */
  static async upload<T>(url: string, fileUri: string): Promise<T> {
    const uploadSession = rcp.createSession({
      baseAddress: BASE_URL,
      interceptors: [new TokenInterceptor(), new LogInterceptor()]
    });

    try {
      if (url.startsWith('/')) {
        url = url.substring(1);
      }
      
      const req = new rcp.Request(BASE_URL + url, 'POST');
      const form = new rcp.MultipartForm({
        'file': {
          contentOrPath: fileUri
        }
      });

      req.content = form;
      const resp = await uploadSession.fetch(req);
      return HttpUtil.handleResponse<T>(resp);
    } catch (err) {
      return HttpUtil.handleError(err);
    } finally {
      uploadSession.close();
    }
  }

  private static handleResponse<T>(resp: rcp.Response): Promise<T> {
    if (resp.statusCode !== 200) {
      try {
        const errBody = resp.toString();
        console.error(`å–µï¼[HttpUtil] é200å“åº”è¯¦æƒ…: ${errBody}`);
      } catch (e) {}
      return Promise.reject(`HTTP Error: ${resp.statusCode}`);
    }
    
    const result = resp.toJSON() as Result<T>;
    if (result.code === 1) {
      return Promise.resolve(result.data);
    } else {
      const errorMsg = result.msg || 'æœªçŸ¥é”™è¯¯';
      HttpUtil.handleError(errorMsg);
      return Promise.reject(errorMsg);
    }
  }

  private static handleError(err: Object): Promise<never> {
    let msg = 'ç½‘ç»œå¼€å°å·®äº†å–µ';
    if (typeof err === 'string') {
      msg = err;
    } else if (err instanceof Error) {
      msg = err.message;
    }

    console.error(`[HttpUtil] Error: ${msg}`);
    try {
       if (HttpUtil.uiContext) {
         HttpUtil.uiContext.getPromptAction().showToast({ message: msg });
       } else {
         promptAction.showToast({ message: msg });
       }
    } catch (e) {}
    
    return Promise.reject(msg);
  }
}
