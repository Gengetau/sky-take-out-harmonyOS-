import { abilityAccessCtrl, bundleManager, common, Permissions } from '@kit.AbilityKit';
import { geoLocationManager } from '@kit.LocationKit';
import { BusinessError } from '@kit.BasicServicesKit';

/**
 * åæ ‡å¯¹è±¡
 */
export interface GeoPoint {
  latitude: number;
  longitude: number;
}

/**
 * å®šä½ä¸æƒé™å·¥å…·ç±»
 */
export class LocationUtil {
  
  /**
   * ç”³è¯·å®šä½æƒé™
   */
  static async requestLocationPermission(context: common.UIAbilityContext): Promise<boolean> {
    const atManager = abilityAccessCtrl.createAtManager();
    const permissions: Permissions[] = [
      'ohos.permission.APPROXIMATELY_LOCATION',
      'ohos.permission.LOCATION'
    ];

    try {
      const result = await atManager.requestPermissionsFromUser(context, permissions);
      const isGranted = result.authResults.every(auth => auth === 0);
      return isGranted;
    } catch (err) {
      console.error('ç”³è¯·æƒé™å¤±è´¥:', JSON.stringify(err));
      return false;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²æœ‰æƒé™
   */
  static async checkPermission(permission: Permissions): Promise<boolean> {
    const atManager = abilityAccessCtrl.createAtManager();
    const bundleInfo = await bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
    const tokenId = bundleInfo.appInfo.accessTokenId;

    try {
      const grantStatus = await atManager.checkAccessToken(tokenId, permission);
      return grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED;
    } catch (err) {
      return false;
    }
  }

  /**
   * ğŸŒ è·å–å½“å‰ä½ç½® (å•æ¬¡å®šä½)
   */
  static async getCurrentLocation(context: common.UIAbilityContext): Promise<GeoPoint | null> {
    const hasPermission = await LocationUtil.requestLocationPermission(context);
    if (!hasPermission) {
      return null;
    }

    try {
      const requestInfo: geoLocationManager.CurrentLocationRequest = {
        'priority': geoLocationManager.LocationRequestPriority.FIRST_FIX,
        'scenario': geoLocationManager.LocationRequestScenario.UNSET,
        'maxAccuracy': 0
      };
      
      const location = await geoLocationManager.getCurrentLocation(requestInfo);
      return {
        latitude: location.latitude,
        longitude: location.longitude
      };
    } catch (err) {
      return null;
    }
  }

  /**
   * ğŸ—ºï¸ é€†åœ°ç†ç¼–ç ï¼šç»çº¬åº¦è½¬è¯¦ç»†åœ°å€ (æ–°å¢)
   */
  static async getAddressFromLocation(latitude: number, longitude: number): Promise<string> {
    try {
      const reverseGeocodeRequest: geoLocationManager.ReverseGeoCodeRequest = {
        'latitude': latitude,
        'longitude': longitude,
        'maxItems': 1,
        'locale': 'zh'
      };
      const addresses = await geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest);
      
      if (addresses && addresses.length > 0) {
        const addr = addresses[0];
        // ä¼˜å…ˆå–å»ºç­‘ç‰©/åœ°æ ‡åï¼Œå…¶æ¬¡å–è·¯åå–µ
        return addr.placeName || addr.roadName || addr.subLocality || 'æœªçŸ¥ä½ç½®';
      }
      return 'ä½ç½®è§£æä¸­';
    } catch (err) {
      console.error('è§£æåœ°å€å¤±è´¥å–µ', err);
      return 'ä½ç½®è§£æå¤±è´¥';
    }
  }
}
