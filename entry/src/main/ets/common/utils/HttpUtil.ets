/**
 * HttpUtil,å°è£…RCPå·¥å…·ç±»
 */

import { rcp } from '@kit.RemoteCommunicationKit';
import { Result } from '../../model/api/ResultModel';

const BASE_URL = 'http://192.168.0.210:8080'; // åç«¯springBootåœ°å€
const TIMEOUT = 5000; // è¶…æ—¶æ—¶é—´

/**
 * æ‹¦æˆªå™¨ï¼Œè´Ÿè´£ç»™è¯·æ±‚å¤´åŠ ä¸Š token
 */
class TokenInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    // ä» AppStorage è·å– token
    const token = AppStorage.get<string>('token');

    if ( token ) {
      if (!context.request.headers ) {
        context.request.headers = {}; // å¦‚æœæ²¡æœ‰ï¼Œå°±åˆå§‹åŒ–ä¸€ä¸ªç©ºå¯¹è±¡
      }
      context.request.headers['authentication'] = token;
    }

    // æ”¾è¡Œï¼Œç»§ç»­è¯·æ±‚
    return next.handle(context);
  }
}

class LogInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    // ğŸŸ¢ 1. æ‰“å°è¯·æ±‚ä¿¡æ¯
    console.info(`å–µï¼[Request] URL: ${ context.request.url.href }`);
    console.info(`å–µï¼[Request] Method: ${ context.request.method }`);

    // ğŸ“¦ 2. å·çœ‹è¯·æ±‚ä½“ (Body)
    const content = context.request.content;
    if ( content ) {
      // å¦‚æœæ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡ï¼Œå°è¯•è½¬ JSON æ‰“å°
      try {
        console.info(`å–µï¼[Request Body]: ${ JSON.stringify(content) }`);
      } catch ( e ) {
        // å¦‚æœæ˜¯äºŒè¿›åˆ¶æµ (ArrayBuffer) æˆ–è€…å…¶ä»–å¤æ‚ç±»å‹ï¼Œå¯èƒ½æ— æ³•ç›´æ¥ stringify
        console.info(`å–µï¼[Request Body]: (Binary or Complex Data) ${ content }`);
      }
    } else {
      console.info(`å–µï¼[Request Body]: (Empty)`);
    }

    // ğŸ‘‰ 3. æ”¾è¡Œï¼Œè®©è¯·æ±‚ç»§ç»­
    const response = await next.handle(context);

    // ğŸ”µ 4. é¡ºä¾¿æ‰“å°ä¸€ä¸‹å“åº”çŠ¶æ€
    console.info(`å–µï¼[Response] Code: ${ response.statusCode }`);

    // å¦‚æœæƒ³çœ‹å“åº”å†…å®¹ï¼Œä¹Ÿå¯ä»¥åœ¨è¿™é‡Œæ‰“å° response.toString()
    // ä½†è¦æ³¨æ„ï¼šå¦‚æœåœ¨è¿™é‡Œè¯»å–äº†å“åº”æµï¼Œå¯èƒ½ä¼šå¯¼è‡´åé¢ä¸šåŠ¡å±‚è¯»ä¸åˆ°ï¼ŒRCP å¤„ç†è¿™ä¸ªæ¯”è¾ƒæ™ºèƒ½ï¼Œé€šå¸¸æ²¡é—®é¢˜ã€‚

    return response;
  }
}

/**
 * å…¨å±€Httpå·¥å…·
 */
export class HttpUtil {
  // å•ä¾‹ session
  private static session: rcp.Session | null = null;
  private static uiContext: UIContext | null = null;

  // 2. æ–°å¢ï¼šæä¾›ä¸€ä¸ªæ–¹æ³•è®©å¤–éƒ¨æŠŠ Context ä¼ è¿›æ¥
  static setContext(context: UIContext) {
    HttpUtil.uiContext = context;
  }

  // åˆå§‹åŒ–session
  private static init() {
    if ( HttpUtil.session === null ) {
      HttpUtil.session = rcp.createSession({
        baseAddress: BASE_URL,
        headers: {
          'Content-Type': 'application/json'
        },
        interceptors: [ new TokenInterceptor(), new LogInterceptor() ]
      });
    }
  }

  static async post<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();

    try {
      // å‘èµ·è¯·æ±‚
      const resp = await HttpUtil.session!.post(url, data);

      // å¤„ç†å“åº”
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  /**
   *  é€šç”¨ GET è¯·æ±‚
   */
  static async get<T>(url: string): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.get(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  static async put<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.put(url, data);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  static async delete<T>(url: string): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.delete(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  /**
   *  æ ¸å¿ƒé€»è¾‘ï¼šç»Ÿä¸€å¤„ç†åç«¯è¿”å›çš„ç»“æœ
   */
  private static handleResponse<T>(resp: rcp.Response): Promise<T> {
    // 1. æ£€æŸ¥ HTTP çŠ¶æ€ç  (200 OK)
    if ( resp.statusCode !== 200 ) {
      return Promise.reject(`HTTP Error: ${ resp.statusCode }`);
    }

    // 2. è§£æ JSON æ•°æ®
    // è‹ç©¹å¤–å–çš„ç»“æ„: { code: 1, msg: "...", data: ... }
    const result = resp.toJSON() as Result<T>;

    // 3. ä¸šåŠ¡é€»è¾‘åˆ¤æ–­
    if ( result.code === 1 ) {
      //  æˆåŠŸï¼ç›´æ¥æŠŠ data å‰¥ç¦»å‡ºæ¥è¿”å›ç»™ UIï¼Œæ–¹ä¾¿ï¼
      return Promise.resolve(result.data);
    } else {
      //  ä¸šåŠ¡å¤±è´¥ (æ¯”å¦‚å¯†ç é”™è¯¯)
      const errorMsg = result.msg || 'æœªçŸ¥é”™è¯¯';

      // å…¨å±€å¼¹çª—æŠ¥é”™ (çœå¾—æ¯ä¸ªé¡µé¢éƒ½å†™)
      HttpUtil.handleError(errorMsg);

      // å¦‚æœæ˜¯ Token è¿‡æœŸ (æ¯”å¦‚ code === 0 && msg === 'NOT_LOGIN')
      if ( errorMsg === 'NOT_LOGIN' ) {
        // TODO: è¿™é‡Œå¯ä»¥åŠ è·³è½¬å›ç™»å½•é¡µçš„é€»è¾‘
      }

      return Promise.reject(errorMsg);
    }
  }

  /**
   * ğŸ›¡ï¸ ç»Ÿä¸€å¤„ç†ç½‘ç»œå±‚é¢çš„å¼‚å¸¸
   */
  private static handleError(err: Object): Promise<never> {
    let msg = 'ç½‘ç»œå¼€å°å·®äº†';
    let error = err as BusinessError;
    // ç„¶ååˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯çœŸçš„æœ‰ code å±æ€§
    if ( error && error.code !== undefined ) {
      // è¯´æ˜å®ƒç¡®å®æ˜¯ BusinessError (æ¯”å¦‚ RCP æŠ›å‡ºçš„ 404, 500 ç­‰)
      msg = `è¯·æ±‚å¼‚å¸¸: ${ error.message } (Code: ${ error.code })`;
    } else if ( err instanceof Error ) {
      // æ™®é€šçš„ JS Error
      msg = err.message;
    } else {
      // å…¶ä»–å¥‡æ€ªçš„é”™è¯¯ (æ¯”å¦‚ç›´æ¥æŠ›å‡ºä¸€ä¸ªå­—ç¬¦ä¸²)
      msg = String(err);
    }

    console.error(`[HttpUtil] Error: ${ msg }`);

    // ä½¿ç”¨æ³¨å…¥çš„ Context å¼¹çª—
    if ( HttpUtil.uiContext ) {
      HttpUtil.uiContext.getPromptAction().showToast({
        message: msg
      });
    }

    // è¿”å›ä¸€ä¸ªå¤±è´¥çš„ Promise
    return Promise.reject(msg);
  }
}

