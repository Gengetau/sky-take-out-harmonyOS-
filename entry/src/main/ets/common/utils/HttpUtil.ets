/**
 * HttpUtil,å°è£…RCPå·¥å…·ç±» (å…¨RCPç‰ˆï¼Œä¸Šä¼ åŠŸèƒ½ä½¿ç”¨Buffer+MultipartForm)
 */

import { rcp } from '@kit.RemoteCommunicationKit';
import { Result } from '../../model/api/ResultModel';

const BASE_URL = 'http://192.168.0.210:8080'; // åç«¯springBootåœ°å€
const TIMEOUT = 5000; // è¶…æ—¶æ—¶é—´

/**
 * æ‹¦æˆªå™¨ï¼Œè´Ÿè´£ç»™è¯·æ±‚å¤´åŠ ä¸Š token
 */
class TokenInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    const token = AppStorage.get<string>('token');
    if ( token ) {
      if (!context.request.headers ) {
        context.request.headers = {};
      }
      context.request.headers['authentication'] = token;
    }
    return next.handle(context);
  }
}

class LogInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise<rcp.Response> {
    console.info(`å–µï¼[Request] URL: ${ context.request.url.href }`);
    console.info(`å–µï¼[Request] Method: ${ context.request.method }`);
    const response = await next.handle(context);
    console.info(`å–µï¼[Response] Code: ${ response.statusCode }`);
    return response;
  }
}

/**
 * å…¨å±€Httpå·¥å…·
 */
export class HttpUtil {
  private static session: rcp.Session | null = null;
  private static uiContext: UIContext | null = null;

  static setContext(context: UIContext) {
    HttpUtil.uiContext = context;
  }

  private static init() {
    if ( HttpUtil.session === null ) {
      HttpUtil.session = rcp.createSession({
        baseAddress: BASE_URL,
        headers: {
          'Content-Type': 'application/json'
        },
        interceptors: [ new TokenInterceptor(), new LogInterceptor() ]
      });
    }
  }

  static async post<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.post(url, data);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  static async get<T>(url: string): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.get(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  static async put<T>(url: string, data?: object): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.put(url, data);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  static async delete<T>(url: string): Promise<T> {
    HttpUtil.init();
    try {
      const resp = await HttpUtil.session!.delete(url);
      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    }
  }

  /**
   * ğŸ“¤ ä¸Šä¼ æ–‡ä»¶ (RCP å®˜æ–¹æ¨èè‡ªå®šä¹‰æ–¹å¼)
   * æ ¹æ® API 11+ æ–‡æ¡£ï¼Œå¯¹äºéœ€è¦æŒ‡å®šå­—æ®µåçš„ MultipartForm ä¸Šä¼ ï¼š
   * 1. ä½¿ç”¨ rcp.MultipartForm åŒ…è£…æ•°æ®ã€‚
   * 2. å¯¹äºæ–‡ä»¶å­—æ®µï¼ŒcontentOrPath å±æ€§å¯ä»¥ç›´æ¥æ¥å—æ–‡ä»¶è·¯å¾„å­—ç¬¦ä¸²ã€‚
   */
  static async upload<T>(url: string, fileUri: string): Promise<T> {
    // âš ï¸ ä½¿ç”¨ä¸´æ—¶ Sessionï¼Œé¿å…å…¨å±€ Session çš„ 'Content-Type': 'application/json' å¹²æ‰° boundary ç”Ÿæˆ
    const uploadSession = rcp.createSession({
      baseAddress: BASE_URL,
      interceptors: [ new TokenInterceptor(), new LogInterceptor() ]
    });

    try {
      const req = new rcp.Request(BASE_URL + url, 'POST');

      // æ„é€ å¤šéƒ¨åˆ†è¡¨å•
      // æ ¹æ®ç±»å‹å®šä¹‰ï¼šFormFieldFileValue åŒ…å« contentOrPath å±æ€§ï¼Œå®ƒæ¥å— string ç±»å‹ï¼ˆæ–‡ä»¶è·¯å¾„ï¼‰
      const form = new rcp.MultipartForm({
        'file': {
          contentOrPath: fileUri
        }
      });

      req.content = form;

      // RCP ä¼šè‡ªåŠ¨è®¾ç½® Content-Type ä¸º multipart/form-data å¹¶ç”Ÿæˆéšæœº boundary
      const resp = await uploadSession.fetch(req);

      return HttpUtil.handleResponse<T>(resp);
    } catch ( err ) {
      return HttpUtil.handleError(err);
    } finally {
      uploadSession.close();
    }
  }

  private static handleResponse<T>(resp: rcp.Response): Promise<T> {
    if ( resp.statusCode !== 200 ) {
      return Promise.reject(`HTTP Error: ${ resp.statusCode }`);
    }
    const result = resp.toJSON() as Result<T>;
    if ( result.code === 1 ) {
      return Promise.resolve(result.data);
    } else {
      const errorMsg = result.msg || 'æœªçŸ¥é”™è¯¯';
      HttpUtil.handleError(errorMsg);
      return Promise.reject(errorMsg);
    }
  }

  private static handleError(err: Object): Promise<never> {
    let msg = 'ç½‘ç»œå¼€å°å·®äº†';
    if ( typeof err === 'string' ) {
      msg = err;
    }

    console.error(`[HttpUtil] Error: ${ msg }`);
    if ( HttpUtil.uiContext ) {
      HttpUtil.uiContext.getPromptAction().showToast({ message: msg });
    }
    return Promise.reject(msg);
  }
}
