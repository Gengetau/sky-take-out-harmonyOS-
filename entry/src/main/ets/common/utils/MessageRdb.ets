import { common } from '@kit.AbilityKit';
import { relationalStore, ValuesBucket } from '@kit.ArkData';

/**
 * ä¼šè¯å®ä½“
 */
export interface SessionModel {
  sessionId: string; // ä¼šè¯ID (å¦‚ "user_101", "shop_1")
  title: string; // æ ‡é¢˜ (å¯¹æ–¹æ˜µç§°/åº—é“ºå)
  avatar: string; // å¤´åƒ
  lastMsg: string; // æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹
  lastTime: number; // æœ€åä¸€æ¡æ¶ˆæ¯æ—¶é—´
  unreadCount: number; // æœªè¯»æ•°
}

/**
 * æ¶ˆæ¯å®ä½“ (å¯¹åº” RDB å­˜å‚¨ç»“æ„)
 */
export interface MessageEntity {
  id?: number; // è‡ªå¢ä¸»é”®
  sessionId: string; // å…³è”ä¼šè¯ID
  msgId: string; // æ¶ˆæ¯UUID
  senderId: number; // å‘é€è€…ID
  role: number; // å‘é€è€…è§’è‰² (0:æˆ‘, 1:å¯¹æ–¹) - ç”¨äºUIåˆ¤æ–­å·¦å³
  content: string; // å†…å®¹
  type: number; // æ¶ˆæ¯ç±»å‹
  createTime: number; // æ—¶é—´æˆ³
  orderId?: number; // å…³è”è®¢å•ID (å¯é€‰)
}

/**
 * ğŸ“¨ æ¶ˆæ¯ä¸­å¿ƒæ•°æ®åº“å·¥å…·ç±» (RDB)
 * ç®¡ç†ä¼šè¯åˆ—è¡¨ (tb_session) å’Œ æ¶ˆæ¯æ˜ç»† (tb_message)
 */
export class MessageRdb {
  private static readonly DB_NAME = 'SkyDelivery_Msg.db';
  private static readonly TABLE_SESSION = 'tb_session';
  private static readonly TABLE_MESSAGE = 'tb_message';
  private static rdbStore: relationalStore.RdbStore | null = null;
  // å®šä¹‰æ•°æ®åº“ç‰ˆæœ¬ï¼Œç”¨äºå‡çº§
  private static readonly DB_VERSION = 2;
  // å»ºè¡¨è¯­å¥ - ä¼šè¯è¡¨
  private static readonly SQL_CREATE_SESSION = `
    CREATE TABLE IF NOT EXISTS tb_session (
      session_id TEXT PRIMARY KEY,
      title TEXT,
      avatar TEXT,
      last_msg TEXT,
      last_time INTEGER,
      unread_count INTEGER
    )
  `;
  // å»ºè¡¨è¯­å¥ - æ¶ˆæ¯è¡¨
  // æ³¨æ„ï¼šSQLite ä¸æ”¯æŒ IF NOT EXISTS é‡Œå¸¦ ADD COLUMNï¼Œæ‰€ä»¥è¿™é‡Œåªå®šä¹‰åˆå§‹ç»“æ„
  // å¦‚æœæ˜¯æ—§ç‰ˆæœ¬å‡çº§ä¸Šæ¥ï¼Œéœ€è¦ ALTER TABLE
  private static readonly SQL_CREATE_MESSAGE = `
    CREATE TABLE IF NOT EXISTS tb_message (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id TEXT NOT NULL,
      msg_id TEXT,
      sender_id INTEGER,
      role INTEGER,
      content TEXT,
      type INTEGER,
      create_time INTEGER,
      order_id INTEGER
    )
  `;

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  static async init(context: common.UIAbilityContext) {
    if ( MessageRdb.rdbStore ) {
      return;
    }

    const config: relationalStore.StoreConfig = {
      name: MessageRdb.DB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1
    };

    try {
      MessageRdb.rdbStore = await relationalStore.getRdbStore(context, config);

      // åˆ›å»ºè¡¨ (å¦‚æœä¸å­˜åœ¨)
      await MessageRdb.rdbStore.executeSql(MessageRdb.SQL_CREATE_SESSION);

      // æ£€æŸ¥ tb_message æ˜¯å¦å­˜åœ¨ä»¥åŠæ˜¯å¦æœ‰ order_id å­—æ®µ
      // æš´åŠ›å°è¯•æ·»åŠ å­—æ®µï¼Œå¿½ç•¥ "duplicate column name" é”™è¯¯
      try {
        await MessageRdb.rdbStore.executeSql('ALTER TABLE tb_message ADD COLUMN order_id INTEGER');
        console.info('å–µï¼æˆåŠŸä¸º tb_message æ·»åŠ  order_id å­—æ®µ ğŸ‰');
      } catch ( e ) {
        // é”™è¯¯ç  1 æˆ–åŒ…å« "duplicate" é€šå¸¸è¡¨ç¤ºå­—æ®µå·²å­˜åœ¨
        console.warn('å°è¯•æ·»åŠ  order_id å­—æ®µæ—¶æç¤º:', JSON.stringify(e));
      }

      console.info('å–µï¼æ¶ˆæ¯æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ ğŸ“¨');
    } catch ( err ) {
      console.error('æ¶ˆæ¯æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥', err);
    }
  }

  // ==================== ä¼šè¯ç®¡ç† ====================

  /**
   * ä¿å­˜æˆ–æ›´æ–°ä¼šè¯
   */
  static async saveSession(session: SessionModel): Promise<boolean> {
    if (!MessageRdb.rdbStore ) {
      return false;
    }

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.equalTo('session_id', session.sessionId);
    const resultSet = await MessageRdb.rdbStore.query(predicates);

    const values: ValuesBucket = {
      'session_id': session.sessionId,
      'title': session.title,
      'avatar': session.avatar,
      'last_msg': session.lastMsg,
      'last_time': session.lastTime
    };

    try {
      if ( resultSet.rowCount > 0 ) {
        resultSet.goToFirstRow();
        const currentUnread = resultSet.getLong(resultSet.getColumnIndex('unread_count'));
        let newUnread = 0;
        if ( session.unreadCount === 0 ) {
          newUnread = 0;
        } else {
          newUnread = currentUnread + session.unreadCount;
        }
        values['unread_count'] = newUnread;
        await MessageRdb.rdbStore.update(values, predicates);
      } else {
        values['unread_count'] = session.unreadCount;
        await MessageRdb.rdbStore.insert(MessageRdb.TABLE_SESSION, values);
      }
      return true;
    } catch ( e ) {
      console.error('ä¿å­˜ä¼šè¯å¤±è´¥', e);
      return false;
    } finally {
      resultSet.close();
    }
  }

  static async clearUnread(sessionId: string): Promise<boolean> {
    if (!MessageRdb.rdbStore ) {
      return false;
    }
    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.equalTo('session_id', sessionId);

    const values: ValuesBucket = {
      'unread_count': 0
    };

    try {
      await MessageRdb.rdbStore.update(values, predicates);
      return true;
    } catch ( e ) {
      return false;
    }
  }

  static async getSessionList(): Promise<SessionModel[]> {
    if (!MessageRdb.rdbStore ) {
      return [];
    }

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
    predicates.orderByDesc('last_time');

    const resultSet = await MessageRdb.rdbStore.query(predicates);
    const list: SessionModel[] = [];

        while (resultSet.goToNextRow()) {

          list.push({

            sessionId: resultSet.getString(resultSet.getColumnIndex('session_id')),

            title: resultSet.getString(resultSet.getColumnIndex('title')),

            avatar: resultSet.getString(resultSet.getColumnIndex('avatar')),

            lastMsg: resultSet.getString(resultSet.getColumnIndex('last_msg')),

            lastTime: resultSet.getLong(resultSet.getColumnIndex('last_time')),

            unreadCount: resultSet.getLong(resultSet.getColumnIndex('unread_count'))

          });

        }

        resultSet.close();

    

        // âœ¨ ç½®é¡¶é€»è¾‘ï¼šæŠŠ 'system_notify' (Meowå¤–å–) ç§»åŠ¨åˆ°æœ€å‰é¢

        const systemIndex = list.findIndex(s => s.sessionId === 'system_notify');

        if (systemIndex > -1) {

          const systemSession = list.splice(systemIndex, 1)[0];

          list.unshift(systemSession);

        }

    

        return list;

      }

  static async deleteSession(sessionId: string): Promise<boolean> {
    if (!MessageRdb.rdbStore ) {
      return false;
    }

    try {
      const sessPred = new relationalStore.RdbPredicates(MessageRdb.TABLE_SESSION);
      sessPred.equalTo('session_id', sessionId);
      await MessageRdb.rdbStore.delete(sessPred);

      const msgPred = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
      msgPred.equalTo('session_id', sessionId);
      await MessageRdb.rdbStore.delete(msgPred);

      return true;
    } catch ( e ) {
      return false;
    }
  }

  // ==================== æ¶ˆæ¯ç®¡ç† ====================

  static async saveMessage(msg: MessageEntity): Promise<boolean> {
    if (!MessageRdb.rdbStore ) {
      return false;
    }

    const values: ValuesBucket = {
      'session_id': msg.sessionId,
      'msg_id': msg.msgId,
      'sender_id': msg.senderId,
      'role': msg.role,
      'content': msg.content,
      'type': msg.type,
      'create_time': msg.createTime,
      'order_id': msg.orderId || null // å­˜å…¥ orderId
    };

    try {
      await MessageRdb.rdbStore.insert(MessageRdb.TABLE_MESSAGE, values);
      return true;
    } catch ( e ) {
      console.error('ä¿å­˜æ¶ˆæ¯å¤±è´¥', e);
      return false;
    }
  }

  static async getMessages(sessionId: string, limit: number = 50, offset: number = 0): Promise<MessageEntity[]> {
    if (!MessageRdb.rdbStore ) {
      return [];
    }

    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
    predicates.equalTo('session_id', sessionId);
    predicates.orderByAsc('create_time');

    const resultSet = await MessageRdb.rdbStore.query(predicates);
    const list: MessageEntity[] = [];

    while ( resultSet.goToNextRow() ) {
      list.push({
        id: resultSet.getLong(resultSet.getColumnIndex('id')),
        sessionId: resultSet.getString(resultSet.getColumnIndex('session_id')),
        msgId: resultSet.getString(resultSet.getColumnIndex('msg_id')),
        senderId: resultSet.getLong(resultSet.getColumnIndex('sender_id')),
        role: resultSet.getLong(resultSet.getColumnIndex('role')),
        content: resultSet.getString(resultSet.getColumnIndex('content')),
        type: resultSet.getLong(resultSet.getColumnIndex('type')),
        createTime: resultSet.getLong(resultSet.getColumnIndex('create_time')),
        orderId: resultSet.getLong(resultSet.getColumnIndex('order_id')) // è¯»å– orderId
      });
    }
    resultSet.close();
    return list;
  }

  /**
   * åˆ é™¤æŒ‡å®šè®¢å•çš„æ‰€æœ‰æ¶ˆæ¯
   */
  static async deleteMessagesByOrderId(orderId: number): Promise<boolean> {
    if (!MessageRdb.rdbStore ) {
      return false;
    }
    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
    predicates.equalTo('order_id', orderId);
    try {
      await MessageRdb.rdbStore.delete(predicates);
      return true;
    } catch ( e ) {
      return false;
    }
  }

  /**
   * åˆ é™¤æŒ‡å®šå•æ¡æ¶ˆæ¯
   */
  static async deleteMessageById(id: number): Promise<boolean> {
    if (!MessageRdb.rdbStore) return false;
    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
    predicates.equalTo('id', id);
    try {
      await MessageRdb.rdbStore.delete(predicates);
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * æ‰¹é‡åˆ é™¤æ¶ˆæ¯
   * @param ids æ¶ˆæ¯IDåˆ—è¡¨
   */
  static async deleteBatch(ids: number[]): Promise<boolean> {
    if (!MessageRdb.rdbStore || ids.length === 0) return false;
    const predicates = new relationalStore.RdbPredicates(MessageRdb.TABLE_MESSAGE);
    predicates.in('id', ids);
    try {
      await MessageRdb.rdbStore.delete(predicates);
      return true;
    } catch (e) {
      console.error('æ‰¹é‡åˆ é™¤å¤±è´¥', e);
      return false;
    }
  }
}