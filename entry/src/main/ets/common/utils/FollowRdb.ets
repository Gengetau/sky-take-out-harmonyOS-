import { relationalStore } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { ShopVO } from '../../model/entity/ShopModel';

/**
 * ğŸ’– å…³æ³¨é¡¹æ¥å£
 */
export interface FollowItem {
  shopId: number;
  name: string;
  avatar: string;
  createTime: number;
}

/**
 * ğŸ’– ç”¨æˆ·å…³æ³¨æ•°æ®åº“å·¥å…·ç±»
 * ä½¿ç”¨æœ¬åœ° RDB å­˜å‚¨å…³æ³¨çš„åº—é“ºä¿¡æ¯ï¼Œä¿æŠ¤éšç§å–µï¼
 */
export class FollowRdb {
  private static readonly STORE_CONFIG: relationalStore.StoreConfig = {
    name: 'FollowStore.db',
    securityLevel: relationalStore.SecurityLevel.S1
  };
  
  private static readonly TABLE_NAME = 'user_follow';
  
  // SQL å»ºè¡¨è¯­å¥
  private static readonly SQL_CREATE_TABLE = `
    CREATE TABLE IF NOT EXISTS ${FollowRdb.TABLE_NAME} (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      shopId INTEGER NOT NULL,
      name TEXT,
      avatar TEXT,
      createTime INTEGER
    )
  `;

  private rdbStore: relationalStore.RdbStore | null = null;
  private static instance: FollowRdb;

  private constructor() {}

  public static getInstance(): FollowRdb {
    if (!FollowRdb.instance) {
      FollowRdb.instance = new FollowRdb();
    }
    return FollowRdb.instance;
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   */
  async initRdb(context: common.Context): Promise<void> {
    try {
      this.rdbStore = await relationalStore.getRdbStore(context, FollowRdb.STORE_CONFIG);
      if (this.rdbStore) {
        await this.rdbStore.executeSql(FollowRdb.SQL_CREATE_TABLE);
        console.info('å–µï¼å…³æ³¨æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸï¼');
      }
    } catch (err) {
      console.error('å–µï¼å…³æ³¨æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', err);
    }
  }

  /**
   * å…³æ³¨åº—é“º
   */
  async followShop(shop: ShopVO): Promise<boolean> {
    if (!this.rdbStore) return false;
    
    // å…ˆæ£€æŸ¥æ˜¯å¦å·²å…³æ³¨
    const isFollowed = await this.isFollowed(shop.id);
    if (isFollowed) return true;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'shopId': shop.id,
        'name': shop.name,
        'avatar': shop.avatar || '',
        'createTime': new Date().getTime()
      };
      await this.rdbStore.insert(FollowRdb.TABLE_NAME, valueBucket);
      return true;
    } catch (err) {
      console.error('å…³æ³¨å¤±è´¥å–µ:', err);
      return false;
    }
  }

  /**
   * å–æ¶ˆå…³æ³¨
   */
  async unfollowShop(shopId: number): Promise<boolean> {
    if (!this.rdbStore) return false;
    
    try {
      const predicates = new relationalStore.RdbPredicates(FollowRdb.TABLE_NAME);
      predicates.equalTo('shopId', shopId);
      await this.rdbStore.delete(predicates);
      return true;
    } catch (err) {
      console.error('å–æ¶ˆå…³æ³¨å¤±è´¥å–µ:', err);
      return false;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²å…³æ³¨
   */
  async isFollowed(shopId: number): Promise<boolean> {
    if (!this.rdbStore) return false;

    try {
      const predicates = new relationalStore.RdbPredicates(FollowRdb.TABLE_NAME);
      predicates.equalTo('shopId', shopId);
      const resultSet = await this.rdbStore.query(predicates);
      const count = resultSet.rowCount;
      resultSet.close();
      return count > 0;
    } catch (err) {
      console.error('æŸ¥è¯¢å…³æ³¨çŠ¶æ€å¤±è´¥å–µ:', err);
      return false;
    }
  }

  /**
   * è·å–æ‰€æœ‰å…³æ³¨çš„åº—é“ºåˆ—è¡¨
   */
  async getFollowList(): Promise<FollowItem[]> {
    if (!this.rdbStore) return [];

    try {
      const predicates = new relationalStore.RdbPredicates(FollowRdb.TABLE_NAME);
      predicates.orderByDesc('createTime'); // æŒ‰å…³æ³¨æ—¶é—´å€’åº
      const resultSet = await this.rdbStore.query(predicates);
      
      const list: FollowItem[] = [];
      while (resultSet.goToNextRow()) {
        const item: FollowItem = {
          shopId: resultSet.getLong(resultSet.getColumnIndex('shopId')),
          name: resultSet.getString(resultSet.getColumnIndex('name')),
          avatar: resultSet.getString(resultSet.getColumnIndex('avatar')),
          createTime: resultSet.getLong(resultSet.getColumnIndex('createTime'))
        };
        list.push(item);
      }
      resultSet.close();
      return list;
    } catch (err) {
      console.error('è·å–å…³æ³¨åˆ—è¡¨å¤±è´¥å–µ:', err);
      return [];
    }
  }
}