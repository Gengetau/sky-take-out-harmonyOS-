import { common } from '@kit.AbilityKit';
import { CartRdb } from '../common/utils/CartRdb';
import { CartItem, DishVO, SetMealVO } from '../model/entity/ShopModel';

/**
 * ğŸ›’ è´­ç‰©è½¦èšåˆä¿¡æ¯æ¥å£ (ç”¨äºå¤šåº—å±•ç¤ºå–µ)
 */
export interface ShopCartGroup {
  shopId: number;
  count: number;
  amount: number;
  items: CartItem[];
}

/**
 * è´­ç‰©è½¦æœåŠ¡ (RDB æŒä¹…åŒ–ç‰ˆ ğŸ›¡ï¸)
 */
@Observed
export class CartService {
  // ğŸ‘ï¸ å½“å‰åº—é“ºçš„è´­ç‰©è½¦è§†å›¾
  public cartItems: CartItem[] = [];
  
  // å½“å‰æ­£åœ¨æ“ä½œçš„ shopId
  private currentShopId: number = 0;
  
  // RDB æ˜¯å¦å·²å°±ç»ª
  private isRdbReady: boolean = false;

  private constructor() {
  }

  public static getInstance(): CartService {
    let instance = AppStorage.get<CartService>('CartService');
    if (!instance ) {
      instance = new CartService();
      AppStorage.setOrCreate('CartService', instance);
    }
    return instance;
  }

  /**
   * ğŸŒŸ åˆå§‹åŒ– RDB
   */
  async initRdb(context: common.UIAbilityContext) {
    if (this.isRdbReady) return;
    await CartRdb.init(context);
    this.isRdbReady = true;
    console.info('å–µï¼CartService RDB å·²è¿æ¥');
  }

  /**
   * ğŸš€ åˆ‡æ¢å½“å‰åº—é“º
   */
  async switchShop(shopId: number) {
    if (shopId <= 0) return;
    
    this.currentShopId = shopId;
    this.cartItems = []; 

    if (this.isRdbReady) {
      try {
        const items = await CartRdb.getCartByShopId(shopId);
        this.cartItems = items;
        console.info(`å–µï¼å·²ä»RDBåŠ è½½åº—é“º ${shopId} çš„è´­ç‰©è½¦ï¼Œå…± ${items.length} é¡¹`);
      } catch (e) {
        console.error('åŠ è½½åº—é“ºè´­ç‰©è½¦å¤±è´¥', e);
      }
    }
    this.notifyUpdate();
  }

  private notifyUpdate() {
    AppStorage.setOrCreate('CartUpdateSignal', Date.now());
  }

  /**
   * æ·»åŠ å•†å“
   */
  async addItem(dish: DishVO, flavors: string) {
    if (this.currentShopId <= 0) {
      console.warn('å–µï¼æœªæŒ‡å®šåº—é“ºï¼Œæ— æ³•æ·»åŠ è´­ç‰©è½¦');
      return;
    }

    const newItem = new CartItem(dish.id, undefined, dish.name, dish.image, dish.price, 1, flavors);
    const existingItem = this.cartItems.find(item => item.uniqueKey === newItem.uniqueKey);

    if ( existingItem ) {
      existingItem.count++;
      this.cartItems = [ ...this.cartItems ];
      if (this.isRdbReady) {
        await CartRdb.saveItem(this.currentShopId, existingItem);
      }
    } else {
      this.cartItems = [ ...this.cartItems, newItem ];
      if (this.isRdbReady) {
        await CartRdb.saveItem(this.currentShopId, newItem);
      }
    }
    
    this.notifyUpdate();
  }

  /**
   * æ·»åŠ å¥—é¤
   */
  async addSetmeal(setmeal: SetMealVO) {
    if (this.currentShopId <= 0) return;

    const newItem = new CartItem(undefined, setmeal.id, setmeal.name, setmeal.image, setmeal.price, 1, '');
    const existingItem = this.cartItems.find(item => item.uniqueKey === newItem.uniqueKey);

    if ( existingItem ) {
      existingItem.count++;
      this.cartItems = [ ...this.cartItems ];
      if (this.isRdbReady) {
        await CartRdb.saveItem(this.currentShopId, existingItem);
      }
    } else {
      this.cartItems = [ ...this.cartItems, newItem ];
      if (this.isRdbReady) {
        await CartRdb.saveItem(this.currentShopId, newItem);
      }
    }
    
    this.notifyUpdate();
  }

  /**
   * å‡å°‘å•†å“
   */
  async decreaseItem(itemToDecrease: CartItem) {
    const existingItem = this.cartItems.find(item => item.uniqueKey === itemToDecrease.uniqueKey);
    if ( existingItem ) {
      if ( existingItem.count <= 1 ) {
        await this.removeItem(itemToDecrease);
      } else {
        existingItem.count--;
        if (this.isRdbReady) {
          await CartRdb.saveItem(this.currentShopId, existingItem);
        }
        this.notifyUpdate();
      }
    }
  }

  async increaseItem(itemToIncrease: CartItem) {
    const existingItem = this.cartItems.find(item => item.uniqueKey === itemToIncrease.uniqueKey);
    if (existingItem) {
      existingItem.count++;
      if (this.isRdbReady) {
        await CartRdb.saveItem(this.currentShopId, existingItem);
      }
      this.notifyUpdate();
    }
  }

  async removeItem(itemToRemove: CartItem) {
    this.cartItems = this.cartItems.filter(item => item.uniqueKey !== itemToRemove.uniqueKey);
    if (this.isRdbReady) {
      await CartRdb.deleteItem(this.currentShopId, itemToRemove);
    }
    this.notifyUpdate();
  }

  async clearCart() {
    this.cartItems = [];
    if (this.isRdbReady && this.currentShopId > 0) {
      await CartRdb.clearShopCart(this.currentShopId);
    }
    this.notifyUpdate();
  }

  async clearAllCarts() {
    this.cartItems = [];
    if (this.isRdbReady) {
      await CartRdb.clearAll();
    }
    this.notifyUpdate();
  }

  // --- ğŸ“Š ç»Ÿè®¡å±æ€§ ---

  get totalCount(): number {
    return this.cartItems.reduce((sum, item) => sum + item.count, 0);
  }

  get totalPrice(): number {
    return this.cartItems.reduce((sum, item) => sum + ( item.price * item.count ), 0);
  }

  /**
   * ğŸŒ è·å–æ‰€æœ‰åº—é“ºçš„è´­ç‰©è½¦æ€»è§ˆ (ä¾› CartPage ä½¿ç”¨)
   * âœ… ä¿®å¤ ArkTS è¯­æ³•ï¼šä½¿ç”¨æ­£å¼æ¥å£è¿”å›å–µ
   */
  async getAllShopCarts(): Promise<ShopCartGroup[]> {
    if (!this.isRdbReady) return [];
    
    const allCartsMap = await CartRdb.getAllCarts();
    const result: ShopCartGroup[] = [];
    
    // è·å–æ‰€æœ‰é”®åå¹¶éå†å–µ
    const keys = Object.keys(allCartsMap);
    for (let i = 0; i < keys.length; i++) {
      const shopId = Number(keys[i]);
      const items = allCartsMap[shopId];
      if (items && items.length > 0) {
        const count = items.reduce((sum, item) => sum + item.count, 0);
        const amount = items.reduce((sum, item) => sum + (item.price * item.count), 0);
        result.push({ 
          shopId: shopId, 
          count: count, 
          amount: amount, 
          items: items 
        });
      }
    }
    return result;
  }

  // --- ğŸ› ï¸ å·¥å…·æ–¹æ³• ---

  decreaseItemByDish(dishId: number, flavors: string): void {
    const uniqueKey = `${ dishId }_null_${ flavors }`;
    const existingItem = this.cartItems.find(item => item.uniqueKey === uniqueKey);
    if ( existingItem ) {
      this.decreaseItem(existingItem);
    }
  }

  getDishQuantity(dishId: number, flavors: string): number {
    const uniqueKey = `${ dishId }_null_${ flavors }`;
    const existingItem = this.cartItems.find(item => item.uniqueKey === uniqueKey);
    return existingItem ? existingItem.count : 0;
  }

  getTotalQuantityForDish(dishId: number): number {
    return this.cartItems
      .filter(item => item.dishId === dishId)
      .reduce((sum, item) => sum + item.count, 0);
  }
}