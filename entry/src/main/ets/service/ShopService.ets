/**
 * å•†åº—ä¸šåŠ¡
 */
import { HttpUtil } from '../common/utils/HttpUtil';
// å¤ç”¨æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„èšåˆç±»
import { CategoryWithItems } from '../model/entity/MockData';
import { CategoryVO, DishVO, SetMealVO, ShopVO } from '../model/entity/ShopModel';

export class ShopService {
  // ğŸ”— æ¥å£åœ°å€
  private static readonly CAT_URL = '/client/category';
  private static readonly DISH_URL = '/client/dish';
  private static readonly SETMEAL_URL = '/client/setmeal';
  private static readonly SHOP_STATUS_URL = '/client/shop/status';
  private static readonly SHOP_LIST_URL = '/client/shop/list'; // å•†å®¶åˆ—è¡¨
  private static readonly SHOP_DETAIL_URL = '/client/shop'; // å•†å®¶è¯¦æƒ…

  /**
   * 0ï¸âƒ£ è·å–åº—é“ºè¥ä¸šçŠ¶æ€ (å…¨å±€)
   */
  static async getShopStatus(): Promise<number> {
    try {
      const status = await HttpUtil.get<number>(ShopService.SHOP_STATUS_URL);
      return status;
    } catch ( e ) {
      console.error('è·å–åº—é“ºçŠ¶æ€å¤±è´¥å–µ', JSON.stringify(e));
      return 0; // é»˜è®¤è¿”å›ä¼‘æ¯ä¸­
    }
  }

  /**
   * ğŸŒŸ 0.1ï¸âƒ£ è·å–å•†å®¶åˆ—è¡¨ (API 1.2)
   * @param typeId åˆ†ç±»ID
   * @param longitude ç»åº¦
   * @param latitude çº¬åº¦
   * @param page é¡µç 
   */
  static async getShopList(typeId: number, longitude?: number, latitude?: number, page: number = 1): Promise<ShopVO[]> {
    let url = `${ ShopService.SHOP_LIST_URL }/${ typeId }?page=${ page }`;
    if ( longitude !== undefined && latitude !== undefined ) {
      url += `&longitude=${ longitude }&latitude=${ latitude }`;
    }
    try {
      const list = await HttpUtil.get<ShopVO[]>(url);
      return list || [];
    } catch ( e ) {
      console.error('è·å–å•†å®¶åˆ—è¡¨å¤±è´¥å–µ', e);
      return [];
    }
  }

  /**
   * ğŸŒŸ 0.2ï¸âƒ£ è·å–å•†å®¶è¯¦æƒ… (API 1.3)
   * @param id å•†å®¶ID
   */
  static async getShopDetail(id: number): Promise<ShopVO | null> {
    try {
      return await HttpUtil.get<ShopVO>(`${ ShopService.SHOP_DETAIL_URL }/${ id }`);
    } catch ( e ) {
      console.error(`è·å–å•†å®¶ ${ id } è¯¦æƒ…å¤±è´¥å–µ`, e);
      return null;
    }
  }

  /**
   * 1ï¸âƒ£ è·å–åˆ†ç±»åˆ—è¡¨
   */
  static async getCategoryList(): Promise<CategoryVO[]> {
    try {
      const url = `${ ShopService.CAT_URL }/all`;
      const list = await HttpUtil.get<CategoryVO[]>(url);
      return list || [];
    } catch ( err ) {
      console.error('è·å–åˆ†ç±»å¤±è´¥');
      return [];
    }
  }

  /**
   * 2ï¸âƒ£ è·å–æŸåˆ†ç±»ä¸‹çš„èœå“
   */
  static async getDishList(categoryId: number): Promise<DishVO[]> {
    try {
      const url = `${ ShopService.DISH_URL }/${ categoryId }`;
      const list = await HttpUtil.get<DishVO[]>(url);
      return list || [];
    } catch ( err ) {
      console.error(`è·å–åˆ†ç±» ${ categoryId } çš„èœå“å¤±è´¥å–µ`);
      return []; // å¤±è´¥è¿”å›ç©ºæ•°ç»„ï¼Œä¸å½±å“å…¶ä»–åˆ†ç±»æ˜¾ç¤º
    }
  }

  /**
   * 2.5ï¸âƒ£ è·å–æŸåˆ†ç±»ä¸‹çš„å¥—é¤
   */
  static async getSetmealList(categoryId: number): Promise<SetMealVO[]> {
    try {
      const url = `${ ShopService.SETMEAL_URL }/${ categoryId }`;
      const list = await HttpUtil.get<SetMealVO[]>(url);
      return list || [];
    } catch ( err ) {
      console.error(`è·å–åˆ†ç±» ${ categoryId } çš„å¥—é¤å¤±è´¥å–µ`);
      return [];
    }
  }


  /**
   * ğŸš€ 3ï¸âƒ£ ã€æ ¸å¿ƒå¤§æ‹›ã€‘è·å–å…¨åº—æ•°æ® (åˆ†ç±» + èœå“/å¥—é¤) å¹¶ç»„è£…
   * ä¾› UI å±‚ç›´æ¥è°ƒç”¨ï¼Œæ‹¿åˆ°å°±æ˜¯èƒ½ç”¨çš„ç»“æ„ï¼
   */
  static async getShopData(): Promise<CategoryWithItems[]> {
    // A. å…ˆæ‹¿æ‰€æœ‰åˆ†ç±»
    const categories = await ShopService.getCategoryList();
    if ( categories.length === 0 ) {
      return [];
    }

    // B. å¹¶å‘è¯·æ±‚ï¼šåŒæ—¶å»æ‹¿æ¯ä¸€ä¸ªåˆ†ç±»ä¸‹çš„å†…å®¹ (æ•ˆç‡æœ€é«˜ï¼)
    const tasks = categories.map(async(cat) => {
      let items: DishVO[] = [];
      if ( cat.type === 1 ) {
        // èœå“
        items = await ShopService.getDishList(cat.id);
      } else {
        // å¥—é¤ (SetMealVO) -> è½¬æ¢ä¸º DishVO
        const setmeals = await ShopService.getSetmealList(cat.id);
        items = setmeals.map(s => new DishVO(
          s.id,
          s.name,
          s.categoryId,
          s.price,
          s.image,
          s.description,
          s.status,
          cat.name, // categoryName
          []// flavors
        ));
      }
      // ç»„è£…æˆæˆ‘ä»¬è¦çš„ç»“æ„
      return new CategoryWithItems(cat, items);
    });

    // C. ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    const result = await Promise.all(tasks);

    // è¿‡æ»¤æ‰æ²¡æœ‰èœå“çš„åˆ†ç±» (å¯é€‰ï¼Œé˜²æ­¢æ˜¾ç¤ºç©ºæ ‡é¢˜)
    // return result.filter(item => item.items.length > 0);
    return result;
  }
}