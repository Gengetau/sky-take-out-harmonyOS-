import { webSocket } from '@kit.NetworkKit';

/**
 * WebSocket æ¶ˆæ¯æ¥å£å®šä¹‰
 */
interface WebSocketMessage {
  type: number;
  orderId?: number;
  content: string;
}

/**
 * WebSocket æœåŠ¡
 * è´Ÿè´£ä¸åç«¯ä¿æŒé•¿è¿æ¥ï¼Œæ¥æ”¶å®æ—¶æ¶ˆæ¯ï¼ˆå¦‚æ”¯ä»˜æˆåŠŸé€šçŸ¥ï¼‰å–µï¼
 */
export class WebSocketService {
  private static instance: WebSocketService;
  private ws: webSocket.WebSocket | null = null;
  private isConnected: boolean = false;
  private userId: number = 0;
  // ç®€å•çš„äº‹ä»¶ç›‘å¬å™¨ï¼štype -> callback
  private listeners: Map<number, (content: string) => void> = new Map();

  private constructor() {
  }

  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }

  /**
   * åˆå§‹åŒ–å¹¶è¿æ¥ WebSocket
   * @param userId å½“å‰ç”¨æˆ·ID
   * @param host åç«¯åœ°å€ (å¦‚: 192.168.1.5:8080)
   */
  public connect(userId: number, host: string) {
    if (this.isConnected && this.userId === userId) {
      console.info('å–µï¼WebSocket å·²ç»è¿æ¥äº†ï¼Œä¸ç”¨é‡å¤è¿ã€‚');
      return;
    }
    // å¦‚æœå·²ç»æœ‰è¿æ¥ä½† userId å˜äº†ï¼Œå…ˆæ–­å¼€
    if (this.ws) {
      this.close();
    }

    this.userId = userId;
    this.ws = webSocket.createWebSocket();
    
    // æ„é€ è¿æ¥åœ°å€ï¼šws://{host}/ws/{userId}
    const url = `ws://${host}/ws/${userId}`;
    console.info(`å–µï¼å‡†å¤‡è¿æ¥ WebSocket: ${url}`);
    
    this.ws.connect(url, (err, value) => {
      if (!err) {
        console.info(`å–µï¼WebSocket è¿æ¥æˆåŠŸ ğŸ‰: ${url}`);
        this.isConnected = true;
        this.setupListeners();
      } else {
        console.error(`å–µï¼ï¼ï¼WebSocket è¿æ¥å¤±è´¥ ğŸ˜­: ${JSON.stringify(err)}`);
        this.isConnected = false;
      }
    });
  }

  private setupListeners() {
    if (!this.ws) return;

    this.ws.on('open', (err, value) => {
      console.info('å–µï¼WebSocket onOpen äº‹ä»¶è§¦å‘');
    });

    this.ws.on('message', (err, value) => {
      if (!err) {
        // value å¯èƒ½æ˜¯ string æˆ– ArrayBuffer
        const messageStr = value as string;
        console.info(`å–µï¼æ”¶åˆ° WS åŸå§‹æ¶ˆæ¯ ğŸ“©: ${messageStr}`);
        try {
          const msgObj = JSON.parse(messageStr) as WebSocketMessage;
          console.info(`å–µï¼æ¶ˆæ¯è§£ææˆåŠŸ: type=${msgObj.type}, orderId=${msgObj.orderId}, content=${msgObj.content}`);
          
          // æ¶ˆæ¯æ ¼å¼: { type: 1, orderId: 1001, content: "..." }
          if (msgObj && msgObj.type) {
             const callback = this.listeners.get(msgObj.type);
             if (callback) {
               callback(msgObj.content);
             }
             // å¹¿æ’­æ”¯ä»˜æˆåŠŸä¿¡å·
             if (msgObj.type === 1 && msgObj.orderId) { 
                console.info(`å–µï¼å¹¿æ’­ PaySuccessSignal: ${msgObj.orderId}`);
                AppStorage.setOrCreate('PaySuccessSignal', msgObj.orderId);
             }
          }
        } catch (e) {
          console.error('å–µï¼WS æ¶ˆæ¯è§£æå¤±è´¥:', e);
        }
      } else {
        console.error('å–µï¼WS æ¥æ”¶æ¶ˆæ¯é”™è¯¯:', err);
      }
    });

    this.ws.on('close', (err, value) => {
      console.warn(`å–µï¼WebSocket è¿æ¥æ–­å¼€ ğŸ”Œ, code: ${value.code}, reason: ${value.reason}`);
      this.isConnected = false;
      this.ws = null;
      // TODO: è¿™é‡Œå¯ä»¥åŠ è‡ªåŠ¨é‡è¿
    });

    this.ws.on('error', (err) => {
      console.error('å–µï¼WebSocket å‘ç”Ÿé”™è¯¯ âŒ:', JSON.stringify(err));
      this.isConnected = false;
    });
  }

  public close() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
      this.isConnected = false;
      console.info('å–µï¼WebSocket ä¸»åŠ¨å…³é—­');
    }
  }
}
