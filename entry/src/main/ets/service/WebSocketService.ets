import { webSocket } from '@kit.NetworkKit';

/**
 * WebSocket æ¶ˆæ¯åè®®ç»“æ„ (å¯¹åº”æ–‡æ¡£ä¸­çš„ MessageDTO)
 */
export interface WebSocketMessage {
  type: number;         // æ¶ˆæ¯ç±»å‹ (1:ç³»ç»Ÿé€šçŸ¥, 2:è®¢å•çŠ¶æ€, 3:ç§èŠæ¶ˆæ¯)
  msgId: string;        // æ¶ˆæ¯å”¯ä¸€ID
  senderId: number;     // å‘é€è€…ID
  senderRole: number;   // å‘é€è€…èº«ä»½ (0:ç”¨æˆ·, 1:å•†å®¶, 2:ç³»ç»Ÿ)
  receiverId: number;   // æ¥æ”¶è€…ID
  receiverRole: number; // æ¥æ”¶è€…èº«ä»½ (0:ç”¨æˆ·, 1:å•†å®¶)
  senderName: string;   // å‘é€è€…æ˜¾ç¤ºåç§°
  senderAvatar: string; // å‘é€è€…å¤´åƒ (å¸¦ç­¾åURL)
  content: string;      // æ¶ˆæ¯æ­£æ–‡
  timestamp: number;    // å‘é€æ—¶é—´æˆ³
  orderId?: number;     // å…³è”çš„è®¢å•ID (å¯é€‰)
}

/**
 * WebSocket æœåŠ¡
 * è´Ÿè´£ä¸åç«¯ä¿æŒé•¿è¿æ¥ï¼Œæ¥æ”¶å®æ—¶æ¶ˆæ¯ï¼ˆå¦‚æ”¯ä»˜æˆåŠŸé€šçŸ¥ã€ç§èŠç­‰ï¼‰å–µï¼
 */
export class WebSocketService {
  private static instance: WebSocketService;
  private ws: webSocket.WebSocket | null = null;
  private isConnected: boolean = false;
  private userId: number = 0;
  // ç®€å•çš„äº‹ä»¶ç›‘å¬å™¨ï¼štype -> callback
  private listeners: Map<number, (msg: WebSocketMessage) => void> = new Map();

  private constructor() {
  }

  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }

  /**
   * æ³¨å†Œæ¶ˆæ¯ç›‘å¬å™¨
   * @param type æ¶ˆæ¯ç±»å‹
   * @param callback å›è°ƒå‡½æ•°
   */
  public onMessage(type: number, callback: (msg: WebSocketMessage) => void) {
    this.listeners.set(type, callback);
  }

  /**
   * åˆå§‹åŒ–å¹¶è¿æ¥ WebSocket
   * @param userId å½“å‰ç”¨æˆ·ID
   * @param host åç«¯åœ°å€ (å¦‚: 192.168.1.5:8080)
   */
  public connect(userId: number, host: string) {
    if (this.isConnected && this.userId === userId) {
      console.info('å–µï¼WebSocket å·²ç»è¿æ¥äº†ï¼Œä¸ç”¨é‡å¤è¿å–µã€‚');
      return;
    }
    // å¦‚æœå·²ç»æœ‰è¿æ¥ä½† userId å˜äº†ï¼Œå…ˆæ–­å¼€
    if (this.ws) {
      this.close();
    }

    this.userId = userId;
    this.ws = webSocket.createWebSocket();
    
    // æ„é€ è¿æ¥åœ°å€ï¼šws://{host}/ws/{userId}
    const url = `ws://${host}/ws/${userId}`;
    console.info(`å–µï¼å‡†å¤‡è¿æ¥ WebSocket: ${url}`);
    
    this.ws.connect(url, (err, value) => {
      if (!err) {
        console.info(`å–µï¼WebSocket è¿æ¥æˆåŠŸ ğŸ‰: ${url}`);
        this.isConnected = true;
        this.setupListeners();
      } else {
        console.error(`å–µï¼ï¼ï¼WebSocket è¿æ¥å¤±è´¥ ğŸ˜­: ${JSON.stringify(err)}`);
        this.isConnected = false;
      }
    });
  }

  private setupListeners() {
    if (!this.ws) return;

    this.ws.on('open', (err, value) => {
      console.info('å–µï¼WebSocket onOpen äº‹ä»¶è§¦å‘å–µ');
    });

    this.ws.on('message', (err, value) => {
      if (!err) {
        // value å¯èƒ½æ˜¯ string æˆ– ArrayBuffer
        const messageStr = value as string;
        console.info(`å–µï¼æ”¶åˆ° WS åŸå§‹æ¶ˆæ¯ ğŸ“©: ${messageStr}`);
        try {
          const msgObj = JSON.parse(messageStr) as WebSocketMessage;
          console.info(`å–µï¼è§£ææˆåŠŸ: [${msgObj.senderName}] -> ${msgObj.content} (Type: ${msgObj.type})`);
          
          // æ‰§è¡Œæ³¨å†Œçš„ç›‘å¬å™¨
          if (msgObj && msgObj.type) {
             const callback = this.listeners.get(msgObj.type);
             if (callback) {
               callback(msgObj);
             }
             
             // æ”¯ä»˜æˆåŠŸé€»è¾‘å…¼å®¹ (Type 1 é€šå¸¸åŒ…å«æ”¯ä»˜é€šçŸ¥)
             // æŒ‰ç…§ä¸šåŠ¡çº¦å®šï¼Œæ”¯ä»˜æˆåŠŸä¼šé€šè¿‡ Type 1 æˆ– Type 2 å‘é€ï¼Œå¹¶ä¸”åŒ…å« orderId
             if ((msgObj.type === 1 || msgObj.type === 2) && msgObj.orderId && msgObj.content.includes('æ”¯ä»˜æˆåŠŸ')) { 
                console.info(`å–µï¼æ£€æµ‹åˆ°æ”¯ä»˜æˆåŠŸä¿¡å·ï¼Œå¹¿æ’­ PaySuccessSignal: ${msgObj.orderId}`);
                AppStorage.setOrCreate('PaySuccessSignal', msgObj.orderId);
             }

             // è¿˜å¯ä»¥å°†æœ€æ–°æ¶ˆæ¯å­˜å…¥ AppStorage ä¾› UI å“åº”
             AppStorage.setOrCreate('LatestWSMessage', msgObj);
          }
        } catch (e) {
          console.error('å–µï¼WS æ¶ˆæ¯è§£æå¤±è´¥:', e);
        }
      } else {
        console.error('å–µï¼WS æ¥æ”¶æ¶ˆæ¯é”™è¯¯:', err);
      }
    });

    this.ws.on('close', (err, value) => {
      console.warn(`å–µï¼WebSocket è¿æ¥æ–­å¼€ ğŸ”Œ, code: ${value.code}, reason: ${value.reason}`);
      this.isConnected = false;
      this.ws = null;
    });

    this.ws.on('error', (err) => {
      console.error('å–µï¼WebSocket å‘ç”Ÿé”™è¯¯ âŒ:', JSON.stringify(err));
      this.isConnected = false;
    });
  }

  /**
   * å‘é€æ¶ˆæ¯ (ä¸»è¦ç”¨äºç§èŠ)
   * @param msg æ¶ˆæ¯å¯¹è±¡
   */
  public send(msg: Partial<WebSocketMessage>) {
    if (this.ws && this.isConnected) {
      const msgStr = JSON.stringify(msg);
      this.ws.send(msgStr, (err, value) => {
        if (!err) {
          console.info('å–µï¼æ¶ˆæ¯å‘é€æˆåŠŸ');
        } else {
          console.error('å–µï¼æ¶ˆæ¯å‘é€å¤±è´¥:', err);
        }
      });
    } else {
      console.error('å–µï¼WS æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
    }
  }

  public close() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
      this.isConnected = false;
      console.info('å–µï¼WebSocket ä¸»åŠ¨å…³é—­å–µ');
    }
  }
}