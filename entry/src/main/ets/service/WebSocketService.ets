import { webSocket } from '@kit.NetworkKit';

/**
 * WebSocket æ¶ˆæ¯åè®®ç»“æ„ (å¯¹åº”æ–‡æ¡£ä¸­çš„ MessageDTO)
 */
export interface WebSocketMessage {
  type: number; // æ¶ˆæ¯ç±»å‹ (1:ç³»ç»Ÿé€šçŸ¥, 2:è®¢å•çŠ¶æ€, 3:ç§èŠæ¶ˆæ¯)
  msgId: string; // æ¶ˆæ¯å”¯ä¸€ID
  senderId: number; // å‘é€è€…ID
  senderRole: number; // å‘é€è€…èº«ä»½ (0:ç”¨æˆ·, 1:å•†å®¶, 2:ç³»ç»Ÿ)
  receiverId: number; // æ¥æ”¶è€…ID
  receiverRole: number; // æ¥æ”¶è€…èº«ä»½ (0:ç”¨æˆ·, 1:å•†å®¶)
  senderName: string; // å‘é€è€…æ˜¾ç¤ºåç§°
  senderAvatar: string; // å‘é€è€…å¤´åƒ (å¸¦ç­¾åURL)
  content: string; // æ¶ˆæ¯æ­£æ–‡
  timestamp: number; // å‘é€æ—¶é—´æˆ³
  orderId?: number; // å…³è”çš„è®¢å•ID (å¯é€‰)
}

export interface PingMessage {
  type: number,
  content: string
}

/**
 * WebSocket æœåŠ¡ (å•†å®¶ç‰ˆ)
 * è´Ÿè´£ä¸åç«¯ä¿æŒé•¿è¿æ¥å–µï¼
 */
export class WebSocketService {
  private static instance: WebSocketService;
  private ws: webSocket.WebSocket | null = null;
  private isConnected: boolean = false;
  private shopId: number = 0;
  private listeners: Map<number, (msg: WebSocketMessage) => void> = new Map();
  private heartbeatTimer: number = -1;

  private constructor() {
  }

  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance ) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }

  /**
   * æ³¨å†Œæ¶ˆæ¯ç›‘å¬å™¨
   */
  public onMessage(type: number, callback: (msg: WebSocketMessage) => void) {
    this.listeners.set(type, callback);
  }

  /**
   * åˆå§‹åŒ–å¹¶è¿æ¥ WebSocket
   * @param shopId åº—é“ºID
   */
  public connect(shopId: number) {
    if ( this.isConnected && this.shopId === shopId ) {
      console.info('å–µï¼WebSocket å·²ç»è¿æ¥äº†ï¼Œä¸ç”¨é‡å¤è¿å–µã€‚');
      return;
    }
    if ( this.ws ) {
      this.close();
    }

    this.shopId = shopId;
    this.ws = webSocket.createWebSocket();

    // å•†å®¶ç«¯ç‰¹æœ‰å‰ç¼€ S_
    const url = `ws://192.168.0.210:8080/ws/S_${ shopId }`;
    console.info(`å–µï¼å‡†å¤‡è¿æ¥ WebSocket: ${ url }`);

    this.ws.connect(url, (err, value) => {
      if (!err ) {
        console.info(`å–µï¼WebSocket è¿æ¥æˆåŠŸ ğŸ‰`);
        this.isConnected = true;
        this.setupListeners();
        this.startHeartbeat();
      } else {
        console.error(`å–µï¼ï¼ï¼WebSocket è¿æ¥å¤±è´¥ ğŸ˜­: ${ JSON.stringify(err) }`);
        this.isConnected = false;
      }
    });
  }

  private setupListeners() {
    if (!this.ws ) {
      return;
    }

    this.ws.on('open', (err, value) => {
      console.info('å–µï¼WebSocket onOpen äº‹ä»¶è§¦å‘å–µ');
    });

    this.ws.on('message', (err, value) => {
      if (!err ) {
        const messageStr = value as string;
        // console.info(`å–µï¼æ”¶åˆ° WS åŸå§‹æ¶ˆæ¯: ${messageStr}`);

        // å¿½ç•¥ PONG
        if ( messageStr === 'PONG' ) {
          return;
        }

        try {
          const msgObj = JSON.parse(messageStr) as WebSocketMessage;
          // console.info(`å–µï¼è§£ææˆåŠŸ: [${msgObj.senderName}] -> ${msgObj.content}`);

          if ( msgObj && msgObj.type ) {
            const callback = this.listeners.get(msgObj.type);
            if ( callback ) {
              callback(msgObj);
            }
          }
        } catch ( e ) {
          console.error('å–µï¼WS æ¶ˆæ¯è§£æå¤±è´¥:', e);
        }
      }
    });

    this.ws.on('close', (err, value) => {
      console.warn(`å–µï¼WebSocket è¿æ¥æ–­å¼€ ğŸ”Œ`);
      this.isConnected = false;
      this.ws = null;
      this.stopHeartbeat();
    });

    this.ws.on('error', (err) => {
      console.error('å–µï¼WebSocket å‘ç”Ÿé”™è¯¯ âŒ:', JSON.stringify(err));
      this.isConnected = false;
    });
  }

  public send(msg: Partial<WebSocketMessage>) {
    if ( this.ws && this.isConnected ) {
      const msgStr = JSON.stringify(msg);
      this.ws.send(msgStr);
    }
  }

  private startHeartbeat() {
    this.stopHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      if ( this.isConnected && this.ws ) {
        // ä¿®æ”¹ä¸º JSON æ ¼å¼çš„å¿ƒè·³åŒ…ï¼Œä»¥å…¼å®¹åç«¯ MessageDispatcher
        const heartbeatMsg: PingMessage = {
          type: 0,
          content: 'PING'
        };
        this.ws.send(JSON.stringify(heartbeatMsg));
      }
    }, 30000);
  }

  private stopHeartbeat() {
    if ( this.heartbeatTimer !== -1 ) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = -1;
    }
  }

  public close() {
    if ( this.ws ) {
      this.ws.close();
      this.ws = null;
      this.isConnected = false;
      this.stopHeartbeat();
    }
  }
}
